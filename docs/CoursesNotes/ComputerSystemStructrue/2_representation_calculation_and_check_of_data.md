# 第二章 数据的表示、运算与检验

## 2.4 基本运算方法

### 2.4.3 定点除法运算

#### 补码不恢复余数除法

前面以及提及，加减交替法，这是很好理解的，减多了就先记账~~（毕竟领导会改错而不认错）~~。这跟原码二位乘法很像，先减后加。但是难点不在这里，而是异号涉及到够不够减难以判断，其次，商我们知道的是这一位的原码表示，只有在最后取反加一才能够得到补码。但是，不够优雅，本质还是当成原码。

所以来提一个优雅的方案，就是末尾恒置为1。这个操作困扰我很久，理解比较绕所以写下来。参考资料：

- [补码加减交替除法中，什么情况下会出现假余数](https://zhidao.baidu.com/question/361871593811669172.html)
- [补码除法的加减交替法为什么商的末位要恒置为1](https://www.zhihu.com/question/544063179) 参考了其中的一条回答，并且自己写了我理解的回答，与此处内容相同

**注意，以下都是针对异号相除，商为补码的形式，我们希望除法结束就得到补码商和余数。同号跟原码除法相同，够不够减逻辑相同。**原码转补码，需要取反加一，这个加一很麻烦。如果只是取反，我们就可以用相反逻辑，够减为 0，不够减为 1。这就是商末尾为 1 的目的，这是一种舍入，简单来说，商是可以有“误差”的，对应余数变一下就好。

> 修改了例子，之前本来末位为 1，没有变化。

$$
9 \div -4 = -2 \cdots\cdots& 1 \\
9 \div -4 = -3 \cdots\cdots& {-3}
$$

末位是可以调整的，我们恒置为 1 只要保证余数正确就好了。余数绝对值没有超过除数绝对值就是合法的，这只是一个规范问题。也就是说，我们一定可以保证前面的几位都是对的，最后一位需要保证余数合法性。但是，误差不是随便来的，上面的式子 -2 到 -3 是对的，-2 到 -1 就错了，那怎么保证的呢？

原码除法是保证余数和被除数同号的（余数和被除数同号算够减），我们取消了“取反加一”的“加一”，等价于**我们主动把商减一了**，那么余数需要多加一个除数。原码除法保证余数和被除数同号，那么此时余数加了一个除数，余数和除数又是异号的，可以保证加法后，**余数绝对值不超过除数绝对值**。 举个栗子，我们正常求解是得到 （1）式的解，但是得到这个解是很麻烦的，因为不好上商（够减不够减，商的补码表示），但是我们减一后，变成反码，对应关系明朗了，就好上商了。这里我纠结了很久，我以为除了最后一位其他位数都一样的，以为自己理解错了；一样是指原码，但是引入补码后 （1） 的计算根本无法继续，无法上商，所以不需要纠结。这样设计其实原码和补码的除法逻辑很类似，所以说方便设计。

这就使我想起以前某道算法题，有道题一直错：

```cpp
    // printf("%d\n", ans % mod); // WA
    printf("%d\n", (ans % mod) + mod % mod); // AC
```

原码除法是保证余数和被除数同号的：对于除法，我们通过余数与被减数同号判断够减，因为被减数会改变，我们通过**被除数和除数同异号的关系**，转换成余数和除数的关系。所以被除数和除数异号情况下，够减就是余数和除数异号，商为 0（因为“补码”表示，当然，是变补少了加一的补码，说白了就是反码）。最后有余数恢复，而不恢复也是合法的，只是符号不同。

我没有给出一个严谨的证明，此处只是说一个大概，方便理解。水平有限，有错误欢迎指出。

408 复习到计算机组成原理，教材里这部分太简单了，这可能就是由于编写者水平较高，有部分编者认为显然的没有细说，或者是我对严谨性比较苛刻。吐槽某高校的教材，这段话我看了几个小时，正确性证明呢？要是怎么简单怎么来，那可太棒了。

## 2.5 常用的数据校验方法

### 2.5.3 循环冗余校验

多项式的选择不是随意的，一般使用推荐的。记表可以一次得出错误位，这个不是二进制，只是恰巧 1 对应最后一位。可以补零继续除直到余数出现 1.同时，补一个零就左移数据，余数为一即此时尾数错误。修改数据，但余数不改，除到出现初始余数，循环改错完成。

# C++后端开发面试题与知识点汇总

## 基础语言

### C++ 和 C

::: tip 说一下C++和C的区别？

- 面向过程和面向对象的区别
  - **c 语言**：c 语言是**面向过程**的语言，面向过程编程就是分析出解决问题的步骤，然后把这些步骤一步一步的实现，使用的时候一个一个的依次调用就可以了。
  - **c++**：C++是**面向对象**语言，面向对象编程就是把问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。
- 具体语言上的区别
  - **malloc,free && new,delete**：
    - **c 语言**：malloc() 和 free() 是 C 语言中动态申请内存和释放内存的标准库中的函数。
    - **c++**：new 和 delete 是 C++运算符、关键字。new 和 delete 底层其实还是调用了 malloc 和 free。
- 主体不同
  - **c 语言**：是一门面向过程的、抽象化的通用程序设计语言，广泛应用于底层开发。
  - **c++**：是 C 语言的继承，它既可以进行 C 语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计。
- 优势不同
  - **c 语言**：能以简易的方式编译、处理低级存储器。C 语言是仅产生少量的机器语言以及不需要任何运行环境支持便能运行的高效率程序设计语言。
  - **c++**：不仅拥有计算机高效运行的实用性特征，同时还致力于提高大规模程序的编程质量与程序设计语言的问题描述能力。
- 特点不同
  - **c 语言**：提供了许多低级处理的功能，但仍然保持着跨平台的特性，以一个标准规格写出的 C 语言程序可在包括类似嵌入式处理器以及超级计算机等作业平台的许多计算机平台上进行编译。
  - **c++**：在 C++中，类是支持数据封装的工具，对象则是数据封装的实现。C++通过建立用户定义类支持数据封装和数据隐藏。

:::

### static 关键字

::: tip 说一下C++中static关键字的作用

- **第一，为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。**
- **第二，希望某个方法或属性与类而不是对象关联在一起，也就是说，在不创建对象的情况下就可以通过类来直接调用方法或使用类的属性**。

在类中，static 可以用来修饰静态数据成员和静态成员方法

**静态数据成员**

1. 静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变
2. 静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间
3. 静态数据成员可以被初始化，但是只能在类体外进行初始化，若为对静态数据成员赋初值，则编译器会自动为其初始化为 0
4. 静态数据成员既可以通过对象名引用，也可以通过类名引用

**静态成员函数**

1. 静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员。
2. 非静态成员函数有 this 指针，而静态成员函数没有 this 指针。
3. 静态成员函数主要用来方位静态数据成员而不能访问非静态成员。

:::

### 说一说 c++ 中四种 cast 转换

:::tip 说一说 c++ 中四种 cast 转换

```cpp
static_cast<T>(expression);
dynamic_cast<T>(expression);
reinterpret_cast<T>(expression);
const_cast<T>(expression);
```

- `static_cast`：静态转换，最常用的转换，**但是转换的时候不会检查类型来保证转换的安全性**。
- `dynamic_cast`：动态转换，dynamic_cast 转换操作符在执行类型转换时首先将检查能否成功转换，如果能成功转换则转换之，如果转换失败，如果是指针则反回一个 0 值，如果是转换的是引用，则抛出一个 bad_cast 异常，所以在使用 dynamic_cast 转换之间最好使用 if 语句对其转换成功与否进行测试。**T 必须是类的指针、类的引用或者 void \*。**如果 T 是类指针类型，那么 expression 也必须是一个指针，如果 T 是一个引用，那么 expression 也必须是一个引用。
- `reinterpret_cast`：重述转换，此标识符的意思即为数据的二进制形式重新解释，但是不改变其值。T 必须是一个指针、引用、算术类型、函数指针或者成员指针。该操作符用于将一种类型转换为另一种不同的类型，比如可以把一个整型转换为一个指针，或把一个指针转换为一个整型，因此使用该操作符的危险性较高，一般不应使用该操作符。
- `const_cast`：其中 T 必须为指针或引用。**主要是用来去掉 const 属性，**当然也可以加上 const 属性。主要是用前者，后者很少用。

:::

### 指针和引用

::: tip 请回答一下数组和指针的区别

数组是储存相同类型数据的集合，指针是一个地址信息，指向的一个变量在内存地址中的位置，这个变量也可以是指针。

:::

::: tip 说一下 C/C++ 中指针和引用的区别？

指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。1、指针是存储变量地址的变量；引用是变量的别名。2、指针变量定义时不必初始化；引用定义时必须初始化，不然会报错。

:::

### 算法

::: tip 给定三角形ABC和一点P(x,y,z)，判断点P是否在ABC内，给出思路并手写代码

连接三角形内的一点和顶点，在三角形内部必定形成三个三角形，三条新连接的边的角形成的角都会小于 180 度，那么只需要计算角度之和是否为 360 就好了。但是这种方法代码并不好写，思考一下其他方法。

向量同向问题，在三角形内任意一点与顶点相连形成的三个向量，任意两个向量相加后跟另一个向量一定是成钝角的，反之就是成锐角。这个思路可能有问题，就是点在边上需要单独讨论。

查了一下也可以使用面积法，这个思路跟角度是一样的，不过更加好写一点。

:::

::: tip 怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码

对 1 做位运算与，为真不是二的倍数，反之就是 2 的倍数。

循环除 10 取模，循环统计每一位。

:::

### 智能指针

::: tip 请你说一下你理解的 c++ 中的 smart pointer 四个智能指针

`auto_ptr`，`shared_ptr`，`weak_ptr`，`unique_ptr` 其中后三个是 c++11 支持，并且第一个已经被 11 弃用。智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

- `auto_ptr`：采用所有权模式。
- `unique_ptr`：实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。另外 `unique_ptr` 还有更聪明的地方：当程序试图将一个 `unique_ptr` 赋值给另一个时，如果源 `unique_ptr` 是个临时右值，编译器允许这么做；如果源 `unique_ptr` 将存在一段时间，编译器将禁止这么做。
- `shared_ptr`：这种类型的智能指针允许共享，采用计数的方式对当前资源的引用量进行统计，当计数器为 0 时释放资源。
- `weak_ptr`：这是为了解决 `share_ptr` 之间相互引用导致的内存泄露问题，提供了一种弱引用，可以访问指向的 `share_ptr` 或者另一个 `weak_ptr`，但是不会增加引用数，但是可以通过检测管理的对象是否存在，从而避免非法访问。

:::

::: tip 请你回答一下智能指针有没有内存泄露的情况，智能指针的内存泄漏如何解决

存在，当两个 `shared_ptr` 互相指向对方，会导致引用数永远无法到达 0 导致两个指针永远无法被释放。

解决方法就是引入了 `weak_ptr`，这个只能指针的构造函数不会增加引用数，可以通过检测管理的对象是否存在，从而避免非法访问。

:::

::: tip 请你回答一下野指针是什么？

野指针，也就是指向不可用内存区域的指针。一般由于释放内存后指针没有赋值为空，或者指针操作超出作用域，又或者指针为初始化为空导致随机赋值。

:::

### 构造函数与析构函数

::: tip 请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数？

主要是由于多态的问题，当一个父指针指向子类对象的时候，如果析构函数不是虚函数，那么会直接调用父类的析构函数，无法调用到子类的析构函数。

而 C++ 默认的析构函数在未确定是否会被继承的情况下不能随便使用虚函数，因为虚函数表和虚表指针造成额外的内存压力，因此不是虚函数。

:::

::: tip 说一下析构函数的作用

析构函数是一种特殊的函数，在对象生命周期结束时被调用，主要用于清理对象使用的资源。
析构函数常常用于清理在构造函数中分配的资源，例如：

- 释放动态分配的内存
- 关闭打开的文件
- 释放其他资源，例如数据库连接、网络连接等

在设计类时，应该认真考虑如何使用析构函数来管理资源，以保证类的使用者无需关心资源的释放问题。

:::

### 概念区分

::: tip 请你来说一下静态函数和虚函数的区别

静态函数是指属于类本身而不是属于类的对象的函数。它通常用于实现类的公共方法，但不需要使用对象的状态。

虚函数是指允许在派生类中重写基类中的函数的函数。虚函数的目的是允许在运行时根据对象的类型调用合适的函数版本，也就是所谓的多态。

:::

::: tip 请你来说一说重载和覆盖

重载（overloading）指的是在同一作用域内，有多个名称相同的函数，但它们的参数列表不同。这样，在调用这个函数时，编译器会根据调用时提供的实参来选择合适的函数版本。

覆盖（overriding）是指在派生类中重新定义基类中的虚函数，以改变基类中函数的实现方式。

- 重载是在同一作用域内，有多个名称相同的函数，但它们的参数列表不同。覆盖是在派生类中重新定义基类中的虚函数。
- 重载是通过参数列表的不同来区分函数的不同版本。覆盖是在保留基类函数的基础上，对函数的实现做出修改。
- 重载是针对函数的一种特殊形式，而覆盖是针对类的一种继承关系。

:::

::: tip 请你说一说strcpy和strlen

strcpy 和 strlen 是 C 语言标准库中的两个函数，分别用于复制字符串和求字符串长度。strcpy 函数用于将 src 所指向的字符串复制到 dest 所指向的缓冲区。src 和 dest 都必须是以 null 结尾的字符数组（也称为 C 风格字符串）。strlen 函数用于求出 str 所指向的字符串的长度，不包括 null 结尾符。

strcpy 函数存在缓冲区溢出的风险，即将源字符串复制到目标字符数组时可能会将目标字符数组内存填满，导致内存访问越界。strlen 函数会在源字符串中查找 null 结尾符，并返回到 null 结尾符之前的字符数。如果源字符串中没有 null 结尾符，strlen 函数就会一直执行下去，直到遇到没有被初始化的内存区域。

建议在 C++ 中使用 std::strcpy_s 和 std::strlen 函数来处理字符串，以保证安全性。

:::

::: tip 请你说一说你理解的虚函数和多态

虚函数（virtual function）是一种特殊的函数，它可以在派生类中被重新定义，以改变基类中函数的实现方式。这样，在使用指向派生类对象的指针调用虚函数时，会调用派生类中重写的函数版本。

多态（polymorphism）指为不同数据类型的实体提供统一的接口，或使用一个单一的符号来表示多个不同的类型。在 C++ 中，通过虚函数实现多态。

:::

::: tip 请你来回答一下++i和i++的区别

- ++i 的优先级比 i++ 高。
- ++i 直接返回自增后的值，而 i++ 先返回自增前的值

在C++中，对与非内建型别来说，前自增运算（++i）返回的是对象的引用，而后自增运算返回的是对象，返回对象将造成拷贝构造函数更多的调用，所以++i的效率要高与i++。但是，对于内建型别（也就是int,short,char等类型），i++与++i的效率几乎没有区别（因为内建型别没有拷贝构造函数）。

:::

### 其他问题

::: tip 请你来写个函数在main函数执行前先运行

你可以使用 C++ 的静态构造函数来实现在 main 函数执行前先运行的函数。

静态构造函数是一种特殊的函数，它会在程序启动时自动调用，不需要手动调用。静态构造函数的作用是在程序启动时初始化静态变量。

例如，你可以定义一个名为 RunBeforeMain 的函数，并使用静态构造函数在程序启动时自动调用该函数，如下所示：

```cpp
#include <iostream>

void RunBeforeMain()
{
    std::cout << "RunBeforeMain is called" << std::endl;
}

struct Initializer
{
    Initializer()
    {
        RunBeforeMain();
    }
};

// 在全局作用域中定义静态变量
// 这将导致静态构造函数被调用
static Initializer init;

int main()
{
    std::cout << "main is called" << std::endl;
    return 0;
}
```
:::

::: tip 请你来说一下智能指针shared_ptr的实现

shared_ptr 内部维护了一个指针和一个计数器，指针指向动态分配的内存块，计数器记录有多少个 shared_ptr 对象指向该内存块。

当 shared_ptr 对象被销毁时，它会将计数器减 1。当计数器减到 0 时，shared_ptr 会调用 delete 运算符释放内存。

:::

::: tip 请你来说一下C++里的各种变量存放在内存的哪个位置？

- 栈（stack）：栈是程序执行时自动分配的内存区域，用于存储函数的局部变量和临时变量。栈的生命周期与函数的生命周期相同，当函数执行完毕时，栈中的变量会自动被销毁。
- 堆（heap）：堆是程序手动分配的内存区域，用于存储动态分配的变量。堆的生命周期由程序员管理，当不再使用时，需要手动调用 delete。
- 全局/静态存储区（global/static storage）：全局/静态存储区用于存储全局变量和静态变量。全局变量定义在函数外部，作用域为整个程序；静态变量定义在函数内部，作用域为整个程序，但生命周期仅限于程序的执行期间。
- 常量存储区（constant storage）：常量存储区用于存储常量。常量是不可改变的值，例如字符串字面量 "hello" 和数字字面量 42。常量存储区中的值是只读的，不能被修改。
- 程序代码存储区（code storage）：程序代码存储区用于存储程序的指令代码。程序代码存储区中的值是只读的，不能被修改。

:::

::: tip 请你来回答一下const修饰成员函数的目的是什么？

在 C++ 中，const 修饰符可以用来修饰成员函数，表示该函数不会修改对象的任何成员变量。

这样做的目的是为了提供一种方式来保证在调用该函数时，对象的状态不会被改变。例如，如果你希望在调用一个成员函数时，保证对象的状态不会被改变，则可以将该函数声明为 const 类型。

此外，const 修饰的成员函数也可以被常量对象调用，从而提高代码的可读性。

:::

::: tip 如果同时定义了两个函数，一个带const，一个不带，会有问题吗？

如果同时定义了两个函数，一个带 const 修饰，一个不带，则编译器会视它们为两个不同的函数，这是没有问题的。这种编译器会自动决定使用那个函数，对常量才会使用const版本的函数。

:::

::: tip 类型转换和隐式类型转换

在 C++ 中，类型转换可以分为显式类型转换和隐式类型转换。

显式类型转换是指在程序中明确地使用类型转换运算符或类型转换函数来完成类型转换的过程。在 C++ 中，可以使用括号和类型名的形式来进行类型转换，或者使用 C++11 中引入的新型类型转换运算符 static_cast<>。

隐式类型转换是指在程序运行时自动完成的类型转换。在 C++ 中，隐式类型转换通常发生在进行算术运算或赋值时，如果两边的数据类型不同，则会自动进行类型转换。隐式类型转换有可能会带来一些问题，例如在某些情况下可能会导致精度损失或类型不匹配的错误。

:::
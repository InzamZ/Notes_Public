# C++后端开发面试题与知识点汇总

## 基础语言

### C++ 和 C

::: tip 说一下C++和C的区别？

- 面向过程和面向对象的区别
  - **c 语言**：c 语言是**面向过程**的语言，面向过程编程就是分析出解决问题的步骤，然后把这些步骤一步一步的实现，使用的时候一个一个的依次调用就可以了。
  - **c++**：C++是**面向对象**语言，面向对象编程就是把问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。
- 具体语言上的区别
  - **malloc,free && new,delete**：
    - **c 语言**：malloc() 和 free() 是 C 语言中动态申请内存和释放内存的标准库中的函数。
    - **c++**：new 和 delete 是 C++运算符、关键字。new 和 delete 底层其实还是调用了 malloc 和 free。
- 主体不同
  - **c 语言**：是一门面向过程的、抽象化的通用程序设计语言，广泛应用于底层开发。
  - **c++**：是 C 语言的继承，它既可以进行 C 语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计。
- 优势不同
  - **c 语言**：能以简易的方式编译、处理低级存储器。C 语言是仅产生少量的机器语言以及不需要任何运行环境支持便能运行的高效率程序设计语言。
  - **c++**：不仅拥有计算机高效运行的实用性特征，同时还致力于提高大规模程序的编程质量与程序设计语言的问题描述能力。
- 特点不同
  - **c 语言**：提供了许多低级处理的功能，但仍然保持着跨平台的特性，以一个标准规格写出的 C 语言程序可在包括类似嵌入式处理器以及超级计算机等作业平台的许多计算机平台上进行编译。
  - **c++**：在 C++中，类是支持数据封装的工具，对象则是数据封装的实现。C++通过建立用户定义类支持数据封装和数据隐藏。

:::

### static 关键字

::: tip 说一下C++中static关键字的作用

- **第一，为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。**
- **第二，希望某个方法或属性与类而不是对象关联在一起，也就是说，在不创建对象的情况下就可以通过类来直接调用方法或使用类的属性**。

在类中，static 可以用来修饰静态数据成员和静态成员方法

**静态数据成员**

1. 静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变
2. 静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间
3. 静态数据成员可以被初始化，但是只能在类体外进行初始化，若为对静态数据成员赋初值，则编译器会自动为其初始化为 0
4. 静态数据成员既可以通过对象名引用，也可以通过类名引用

**静态成员函数**

1. 静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员。
2. 非静态成员函数有 this 指针，而静态成员函数没有 this 指针。
3. 静态成员函数主要用来方位静态数据成员而不能访问非静态成员。

:::

### 说一说 c++ 中四种 cast 转换

:::tip 说一说 c++ 中四种 cast 转换

```cpp
static_cast<T>(expression);
dynamic_cast<T>(expression);
reinterpret_cast<T>(expression);
const_cast<T>(expression);
```

- `static_cast`：静态转换，最常用的转换，**但是转换的时候不会检查类型来保证转换的安全性**。
- `dynamic_cast`：动态转换，dynamic_cast 转换操作符在执行类型转换时首先将检查能否成功转换，如果能成功转换则转换之，如果转换失败，如果是指针则反回一个 0 值，如果是转换的是引用，则抛出一个 bad_cast 异常，所以在使用 dynamic_cast 转换之间最好使用 if 语句对其转换成功与否进行测试。**T 必须是类的指针、类的引用或者 void \*。**如果 T 是类指针类型，那么 expression 也必须是一个指针，如果 T 是一个引用，那么 expression 也必须是一个引用。
- `reinterpret_cast`：重述转换，此标识符的意思即为数据的二进制形式重新解释，但是不改变其值。T 必须是一个指针、引用、算术类型、函数指针或者成员指针。该操作符用于将一种类型转换为另一种不同的类型，比如可以把一个整型转换为一个指针，或把一个指针转换为一个整型，因此使用该操作符的危险性较高，一般不应使用该操作符。
- `const_cast`：其中 T 必须为指针或引用。**主要是用来去掉 const 属性，**当然也可以加上 const 属性。主要是用前者，后者很少用。

:::

### 指针和引用

::: tip 请回答一下数组和指针的区别

数组是储存相同类型数据的集合，指针是一个地址信息，指向的一个变量在内存地址中的位置，这个变量也可以是指针。

:::

::: tip 说一下 C/C++ 中指针和引用的区别？

指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。1、指针是存储变量地址的变量；引用是变量的别名。2、指针变量定义时不必初始化；引用定义时必须初始化，不然会报错。

:::

### 算法

::: tip 给定三角形ABC和一点P(x,y,z)，判断点P是否在ABC内，给出思路并手写代码

连接三角形内的一点和顶点，在三角形内部必定形成三个三角形，三条新连接的边的角形成的角都会小于 180 度，那么只需要计算角度之和是否为 360 就好了。但是这种方法代码并不好写，思考一下其他方法。

向量同向问题，在三角形内任意一点与顶点相连形成的三个向量，任意两个向量相加后跟另一个向量一定是成钝角的，反之就是成锐角。这个思路可能有问题，就是点在边上需要单独讨论。

查了一下也可以使用面积法，这个思路跟角度是一样的，不过更加好写一点。

:::

::: tip 怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码

对 1 做位运算与，为真不是二的倍数，反之就是 2 的倍数。

循环除 10 取模，循环统计每一位。

:::

### 智能指针

::: tip 请你说一下你理解的 c++ 中的 smart pointer 四个智能指针

`auto_ptr`，`shared_ptr`，`weak_ptr`，`unique_ptr` 其中后三个是 c++11 支持，并且第一个已经被 11 弃用。智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

- `auto_ptr`：采用所有权模式。
- `unique_ptr`：实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。另外 `unique_ptr` 还有更聪明的地方：当程序试图将一个 `unique_ptr` 赋值给另一个时，如果源 `unique_ptr` 是个临时右值，编译器允许这么做；如果源 `unique_ptr` 将存在一段时间，编译器将禁止这么做。
- `shared_ptr`：这种类型的智能指针允许共享，采用计数的方式对当前资源的引用量进行统计，当计数器为 0 时释放资源。
- `weak_ptr`：这是为了解决 `share_ptr` 之间相互引用导致的内存泄露问题，提供了一种弱引用，可以访问指向的 `share_ptr` 或者另一个 `weak_ptr`，但是不会增加引用数，但是可以通过检测管理的对象是否存在，从而避免非法访问。

:::

::: tip 请你回答一下智能指针有没有内存泄露的情况，智能指针的内存泄漏如何解决

存在，当两个 `shared_ptr` 互相指向对方，会导致引用数永远无法到达 0 导致两个指针永远无法被释放。

解决方法就是引入了 `weak_ptr`，这个只能指针的构造函数不会增加引用数，可以通过检测管理的对象是否存在，从而避免非法访问。

:::

::: tip 请你回答一下野指针是什么？

野指针，也就是指向不可用内存区域的指针。一般由于释放内存后指针没有赋值为空，或者指针操作超出作用域，又或者指针为初始化为空导致随机赋值。

:::

### 构造函数与析构函数

::: tip 请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数？

主要是由于多态的问题，当一个父指针指向子类对象的时候，如果析构函数不是虚函数，那么会直接调用父类的析构函数，无法调用到子类的析构函数。

而 C++ 默认的析构函数在未确定是否会被继承的情况下不能随便使用虚函数，因为虚函数表和虚表指针造成额外的内存压力，因此不是虚函数。

:::
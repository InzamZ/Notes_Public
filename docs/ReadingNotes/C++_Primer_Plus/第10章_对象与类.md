# 对象与类

面向对象编程 (OOP) 是一种概念性的编程思想，这不是一种语言的定义，因为 c 语言也可以利用函数指针以及其他方法实现面向对象编程。C++通过加入一些特性使得这种运用更简单了，下面是重要的 OOP 特性：

- 抽象
- 封装和数据隐藏
- 多态
- 继承
- 代码的可复用性

## 10.1 过程性编程和面向对象编程

根本区别在设计上就有所体现了，例如要我实现一个计算器，面向过程编程的程序会编写各自的计算函数，处理输入输出；对于面向对象编程的程序员思考的是首先要有一个计算器的类，然后对应哪些接口，考虑输入输出接口。

## 10.2 抽象与类

### 访问控制

通过 `public`，`private`，`protected` 控制对类成员的访问。类设计尽量将公有接口与实现细节分开，公有接口表示设计的抽象组件，将实现细节放在一起并且与公共接口分开称为封装。

::: tip struct 与 class

事实上两者的唯一区别是默认访问控制限权，struct 是 public，而 class 则是 private。因为 C++对 struct 进行了扩展，让其拥有与 class 相同的功能。但是习惯上还是使用 class 来定义设计类，struct 作为 C 风格的结构体。

:::

### 类成员函数

定义位于类声明中的函数都自动称为内联函数，即函数体在类声明中的函数，一般将短小的函数声明为内联函数。事实上，在声明中定义与定义时在前面加上 `inline` 限定符是等效的。

::: tip 内联函数

在计算机科学中，内联函数 (有时称作在线函数或编译时期展开函数) 是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展 (有时称作在线扩展)；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方 (上下文)，从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。另外还需要特别注意的是对递归函数的内联扩展可能引起部分编译器的无穷编译。

:::

设计原则要求该文件的更改必须局限在当前文件，例如修改了输出的参数，需要在使用前保存原始状态，在函数结束的时候恢复。

```cpp

std::streamsize prec = std::cout.precision[3];
...
std::cout.precision(prec);

```
## 10.3 类的构造函数和析构函数

我们可以使用大括号来初始化结构体，因为如果所有成员都是公有的话，没有访问控制问题。如果存在私有成员就会出现问题，这时候需要构造函数来完成初始化。

### 构造函数

编译器提供默认构造函数，这个构造函数不初始化任何值，没有参数。但是编译器只在类没有任何显式的构造函数时提供，如果存在一个现实构造函数，那么无参数的构造函数也需要程序显示定义。

定义默认构造函数有两种方式，一种是在已有的构造函数中，给每个参数提供默认值；另一种是利用函数重载编写一个没有参数的构造函数。

隐式调用构造函数不需要使用括号，否则语法会与声明函数不同。

```cpp
Stock A();   // 声明一个函数返回一个 Stock 对象
Stock A;     // 调用默认构造函数声明一个 Stock 函数
```

列表初始化语法可用于类，需要提供与类构造函数参数匹配的参数并且使用大括号括起来，就会调用相应的构造函数。空的大括号会调用吗默认构造函数。

### 析构函数

析构函数有编译器决定何时调用，静态储存对象在程序结束的时候自动调用，静态声明的会在代码块结束时调用，使用 new 动态生成的会在调用 delete 的时候自动调用。

当然也存在默认析构函数，在发现导致对象被删除的代码后提供默认析构函数的定义。

## 10.4 this 指针


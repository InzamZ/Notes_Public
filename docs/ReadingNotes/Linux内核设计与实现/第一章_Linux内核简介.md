# 第一章 Linux 内核简介

## 目录
[[toc]]

## 1.1 Unix 的历史

Unix 已经存在 50 年，计算机科学家任然认为它是最强大最优秀的操作系统。 
许多组织对 Unix 进行重开发，影响最大的一个是加州大学伯克利分校的 BSD，其中的 csh，vi 等工具现在还在使用。伯克利在 3BSD 开始自主研发，引入虚拟内存。 
Unix 强大的根本原因：

- 设计简洁，几百个系统调用且有明确的设计目的
- 万物皆文件，几乎所有的东西都表示为文件，可以通过同一套系统调用控制
- 内核和相关的系统工具都是使用 C 编写的，可移植性非常高
- 进程创建快，有一个独特的 `fork()` 系统调用
- 有一套简单稳定的通信元语，使程序集中目标在**一次执行保质保量地完成一个任务**

## 1.2 追寻 Linus 的足迹：Linux 简介

1991 年 Linus Torvalds 为新推出的计算机开发了一款全新的操作系统，就是 Linux。 
当时的 DOS 除了玩波斯王子一无用处，而 Linux 喜欢的 Minix 系统，一款教学用的廉价 Unix，却由于许可证原因不能修改。那么 Linus 开始自己写操作系统。写完原型后在网上发布后得到很多人的认可，并且对其代码进行完善和修改。事实上归功于其许可证，GPL2，所有人都可以拿到代码并修改，但是需要保证修改后的代码保持相同的许可证。 
Linux 并没有直接使用 Unix 的代码，很多时候实现方式大相径庭，但是保持应用程序接口一致的原则。Linux 我们一般指的是内核。
## 1.3 操作系统和内核简介

操作系统包括内核，内核处于核心和管理者地位，用户界面属于外壳。一般内核由一个负责响应处理中断的程序，一个负责管理多个进程分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序和网络，进程间通信等系统服务程序组成。 
现代操作系统具有保护机制，内核独立其他应用程序，处于内核态，具有保护的内存空间和访问所有硬件设备。一般的应用程序只运行在用户态。系统根据运行的不同，运行内核，以内核态进入内核空间运行；应用程序运行时以用户态进入用户空间运行。 
应用程序通过系统调用与内核通信，一般通过库函数进入系统调用界面，让内核代其执行任务。例如调用 `printf` 函数的时候，会执行 `write()`，而 `strcpy` 根本没有调用系统调用。应用程序如果执行一条系统调用，我们称为**内核正在代其运行**，应用程序通过系统调用在内核空间运行，内核则运行在**进程上下文**中。应用程序通过系统调用陷入内核空间，这是应用程序完成其工作的基本行为方式。 
内核还要负责管理硬件设备，一般通过中断机制，硬件设备在想要与系统通信时，会发出一个异步中断信号，打断处理器运行和内核，通过携带的中断号查找对应的中断处理程序，调用其处理中断。中断可以被屏蔽，为了数据的同步，而且许多操作系统，包括 Linux，中断服务系统都运行于中断上下文，与所有的进程无关，为了能第一时间响应中断。 
![image.png](./img/1667996055126-f0f3c17a-48c9-463a-ae9b-1c2a8a67f929.png )
上下文代表活动范围，任意时刻处理器总是处于以下三者之一：

- 运行于用户空间，执行用户进程
- 运行在内核空间，处于进程上下文，代某个特定进程执行
- 运行在内核空间，处于进程上下文，与任何进程无关，处理某个特定中断

就算是处理器没有任何工作，内核就运行一个空进程，处于进程上下文，但运行在内核空间。

## Linux 内核和传统 Unix 内核的比较

Unix 内核基本都是一个不可分割的静态可执行库，也就是说他们必须运行在一个单独的地址空间，需要硬件系统提供页机制 (MMU) 管理内存。

### 单内核和微内核设计的比较

单内核与微内核是操作系统阵营中的两大阵营。第三阵营是外内核，主要用于科研系统中。Unix 系统大部分都是单内核设计，表现为单个静态二进制文件，内核整体上作为一个单独的大过程。这样内核通信和应用程序内部通信一样简单，运行在单独的内核地址空间。
微内核按照功能被分割成多个部分，每个称为服务器。此时内核不再是一个大过程，除非在强烈请求特权服务的情况下才会进入内核空间，否则服务器运行在用户空间，相互独立并且通过消息传递机制处理微内核通信，使用 IPC (进程间通信) 机制，各个服务器之间通过 IPC 互换服务。模块化的系统允许一个服务器为了另一个服务器为了另一个服务器而换出。
由于 IPC 机制的开销大于函数调用，又涉及内核空间和用户空间的上下文转换，所以消息传递具有周期，而单内核并没有。于是大部分基于微内核的系统都直接让服务器运行在内核空间，消除频繁的上下文切换。


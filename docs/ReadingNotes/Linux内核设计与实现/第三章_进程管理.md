# 第三章进程管理

进程是 Unix 系统抽象概念中最基本的一种，本章介绍进程相关概念，以及操作系统如何管理进程，以及进程的生命周期。

## 目录

[[toc]]

## 3.1 进程

**进程是运行中的程序，是程序代码运行的实时结果，是处于执行期的程序以及相关资源的总称**。但不局限于程序代码，还包括资源打开的文件，挂起的信号，内核内部数据，处理器状态，一个或者多个内存地址空间和一个或多个执行线程。

执行线程，简称线程，是在进程中活动的对象。线程是内核调度的对象，一般拥有一个单独的程序计数器，进程栈和一组进程寄存器。传统 Unix 系统一个进程只有一个线程，现代操作系统多线程已经司空见惯。Linux 吧线程看做一种特殊的进程。

进程提供两种虚拟机制，虚拟处理器和虚拟内存。虚拟处理器给进程一种错觉，自己独享所有处理器，事实上是共享的。虚拟内存让内存以为自己独占了整个系统的内存。线程在进程中共享虚拟内存，但是每个线程都有一组自己的虚拟处理器。

Linux 中调用 `fork()` 系统调用复制当前进程，该系统调用返回两次，一次返回父进程继续执行，一次返回子进程开始执行。现代 Linux 系统通过 `clone()` 实现 `fork()`。最后程序调用 `exit()` 退出执行，此函数会终结进程并将资源释放，父进程通过 `wait4()` 系统调用查询子进程是否终结。进程退出执行后处于僵死状态，直到父进程调用 `wait()` 或者 `waitpid()`。

::: tip 任务 (task)

进程别名为任务，作者以内核视角看待进程会称之为任务。

:::

## 3.2 进程描述符及任务结构

内核将进程放入双向循环链表，称为任务队列。每一项都是 `task_struct`，称为进程描述符。与进程控制块 (PBC) 的关系是，PCB 是一个抽象概念，而进程描述符就是 Linux 对这一抽象概念的实现。一句话 Linux 的进程控制块就是进程描述符。

`task_struct` 在 32 位系统中大约是 1.7KB，但是包含了管理一个进程需要的所有信息。

### 分配进程描述符

Linux 通过 slab 分配器分配进程描述符，能达到对象复用和缓存着色。2.6 以前的内核中，各个进程的进程描述符在它们内存栈的尾部，方便寄存器少的硬件体系通过栈指针计算出位置。现在使用 slab 动态分配，在栈底生成 `thread_info`，结构中的 `task` 指针指向进程描述符。

```c
struct thread_info {
    struct task_struct   *task;
    struct exec_domain   *exec_domain;
    ...
}
```

![image-20221116230633388](img/image-20221116230633388.png)

::: info

栈底统一指向下生长的栈，也就是进程的栈的最低地址空间。

:::

### 进程描述符的存放

内核通过唯一的进程标识符，也称为 PID。PID 表示为隐含类型，实际上是一个 int 整型，为了兼容老版本 Unix 和 Linux，这个值默认为 32768，但最多可以更改至四百万，取决于<linux/threads.h>所定义的 PID 最大值限制。

进程最大值就是内核允许的最大进程，这个值越大，转一圈需要的时间就越多；反之，支持的最多同时运行进程数量就越少。内核操作任务都是经过 task_struct 实现的，因此快速获取进程的 task_struct 非常重要，方式是通过 currect 宏，不同硬件平台下 currect 的实现不同，有的硬件平台存在一个寄存器专门储存当前进程 task_struct 指针。对寄存器不富足的 x86 平台只能通过 thread_info 计算偏移量。

```asm
movl $-8192, %eax ;
andl %esp, %eax ;
```

对比 PowerPC，它会直接返回一个 r2 寄存器的值即可，因为 PPC 认为这是一个重要的值，值得专门用一个寄存器去储存。

### 进程状态

进程的状态记录在进程描述符中的 state，所有进程的状态都处于以下五种之一：

- TASK_RUNNING (运行)：进程是可执行，或许正在执行或者在运行队列等待运行，这是在用户空间执行的进程的唯一状态。
- TASK_INTERRUPTIBLE (可中断)：进程正在睡眠，等待某些条件完成后在设置为运行状态。也可能收到信号提前进入进行状态。
- TASK_UNINTERRUPTIBLE (不可中断)：该状态与可中断唯一的区别就是收到信号也不会投入运行。通常是为了进程不受到中断干扰或者等待事件很快就会完成。(此类进程不能被 kill，因为他们可能在执行非常重要的任务，可能还持有信号量，不应该被强制停止。)
- \_\_TASK_TRACED：被其他进程跟踪的进程，例如通过 ptrace 对调试程序进行跟踪
- \_\_TASK_STOPPED (停止)：程序没有投入运行也不可以投入运行。通常发生在程序收到 SIGSTOP，SIGTSTP，SIGTTIN，SIGTTOU。此外调试程序在调试期间接受到任何信号都会进入这个状态。

### 设置当前进程状态

内核通过调用 set_task_state 函数调整某个进程的状态：

```c
set_task_state(task, state);
```

必要的时候会设置内存屏障来强制其他处理器作重新排序，一般只有 SMP 系统中由此必要，否则等价于：

```c
task->state = state;
```

::: tip SMP

[对称多处理](https://zh.wikipedia.org/wiki/对称多处理) (英语：Symmetric multiprocessing，缩写为 SMP)，也译为均衡多处理、对称性多重处理、对称多处理机，是一种多处理器的电脑硬件架构，在对称多处理架构下，每个处理器的地位都是平等的，对资源的使用权限相同。现代多数的多处理器系统，都采用对称多处理架构，也被称为对称多处理系统 (Symmetric multiprocessing system)。在这个系统中，拥有超过一个以上的处理器，这些处理器都连接到同一个共享的主存上，并由单一操作系统来控制。在多核心处理器的例子中，对称多处理架构，将每一个核心都当成是独立的处理器。
在对称多处理系统上，在操作系统的支持下，无论行程是处于用户空间，或是核心空间，都可以分配到任何一个处理器上运行。因此，行程可以在不同的处理器间移动，达到负载平衡，使系统的效率提升。

:::

### 进程上下文

进程由于系统调用或者触发某个异常就会陷入内核空间，内核代替进程执行并处于进程上下文。除了特殊情况，在退出内核时程序会恢复在用户空间继续执行。

系统调用和异常处理程序是对内核明确定义的接口，进程只能通过这些接口才能陷入内核执行。

### 进程家族树

Unix 系统的进程之间有明显的继承关系，在 Linux 系统中也是，所有继承都是一号进程 init 的后代，内核在系统启动的最后阶段启动 init 进程，它读取系统的初始化脚本并执行其他的相关程序，最后完成系统启动的整个过程。

每个进程必定有一个符进程，有零个或者多个子进程，进程描述符中包含一个父进程指针，还有一个子进程链表。init 进程的进程描述符是作为 init_task 金泰分配的。

通过这种关系可以从任意一个进程定位到另一个进程，也可以通过遍历的方式遍历所有的任务列表。

::: warning

一个拥有大量进程的系统便利所有进程的代价很大，所以除非不得已，不要使用这种方法。

:::

## 3.3 进程创建

许多操作系统都有自己的产生进程的机制，在新的地址空间创建进程，引入可执行文件，开始执行。Linux 把这个过程分成两个函数，fork() 和 exec()。其中 fork() 函数通过复制当前的进程创建一个新进程，两者除了 PID、PPID、某些资源与统计量 (例如，被挂起的信号) 其他完全相同。exec() 函数通过读取可执行文件开始执行程序。两者合在一起的功能与其他创建进程的功能类似。

### 3.3.1 写时拷贝

这是一个经典的思想，如果说创建一个副本只是为了读取，那么可以共享一个副本。拷贝是需要开销的，这也是存储中使用的一个重要技术。资源的复制只发生在数据修改的时候，大部分的进程会在 fork 后面就执行 exec，也就是说如果复制了父进程的进程空间，接下来执行新的程序又会覆盖刚刚拷贝的内容，这就是浪费。

子进程到底复制了什么内容呢，fork 的开销是将整个进程空间复制到子进程，用于创建一个新的进程描述符。

### 3.3.2 fork

Linux 通过 clone 系统调用实现了 fork，clone 系统调用通过指定参数，控制了父子进程共享的内容，从而实现不同的进程创建。之后的 fork，vfork，__clone 都是通过 clone 系统调用实现的。

以上的库函数通过调用 clone()，clone() 根据传入参数去调用 do_fork()。do_fork() 执行的大部分工作，随后调用 copy_process()，接下来看一下 copy_process() 的具体工作：

1. 调用 dup_task_struct() 为新进程创建新的内核栈，thread_info 和 task_struct，此时子进程和父进程完全一致
2. 子进程确保创建资源足够，进程数量不会超过限制数量
3. 子进程开始清空部分统计信息，使得自己的进程描述符与父进程区分开来。主要是统计信息而不是从父进程继承的信息。此时 task_struct 的内容大部分没有修改
4. 此时子进程的运行状态设置为 TASK_UNINTERRUPTIBLE，保证其无法投入运行
5. 此时调用 copy_flags() 更新了 task_struct 的 flags 成员。清空是否拥有超级用户权限的标志 PF_SUPERPRIV 置为 0，清空是否运行过 PF_FORKNOEXRC 标志被设置
6. 调用 alloc_pid() 申请分配一个 pid
7. 根据传递的参数标志，copy_process() 拷贝或共享打开的文件，文件系统信息，信号处理函数，进程地址空间和命名空间
8. 完成扫尾工作，返回一个指向子进程的指针

回到 do_fork()，此时内核有意使子进程先运行，得益于写时拷贝，可以减少不必要的拷贝。父进程修改进程的信息会导致复制触发。但是事实不一定如此。

### 3.3.3 vfork

书中 vfork 和 fork 的唯一区别就是页表的拷贝，vfork 会把父进程阻塞掉，在调用 exec 后或者结束子进程才会唤醒父进程。这个设计是有缺陷的，如果 exec 失败会出现问题，而且完全可以使用写时拷贝页表实现。这个在新的 Linux 中应该实现了，书中使用的是 2.6 版本的内核。

## 3.4 Linux 中线程的实现

线程通过共享进程空间和打开的文件和其他资源，同时可以实现并发。一般认为线程是调度的基本单位，进程是资源分配的基本单位。在多处理器系统可以实现真正的并行，而对于单处理器的并发也可以实现资源利用率的提高。

在 Linux 中并没有真正实现线程，而是通过进程，控制共享的内容实现了线程。其他系统会实现线程，称为轻量级的进程，而对于 Linux 而言，Linux 的进程已经够轻量级了，所以和其他系统的差别较大。

在其他专门实现线程系统的实现会在进程描述符描述打开的文件等线程共享的信息，然后进程描述符中指向一些线程。进程描述符中有共享的文件、文件系统信息等。

3.4.1 线程创建

之前提过，clone 的通过不同参数调用可以实现不同的共享内容，Linux 使用这种方式实现共享。

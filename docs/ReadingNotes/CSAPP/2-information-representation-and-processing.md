# 第 2 章：信息的表示和处理

## 2.3 整数运算

### 2.3.4 无符号乘法

无符号乘法的溢出采用的是截断，也就是按照 $2^w$ 取模，注意乘法溢出不只一位！

### 2.3.5 补码乘法

补码乘法与无符号乘法类似，但是毕竟多了符号，好像有点差别，但是补码的性质决定了，无符号数和有符号数截断后的结果相同。书中称之为无符号和补码乘法的位级等价性，有兴趣可以阅读。

::: tip

此处提及一下练习题 2.31 与 2.35，刚才提了一下我的猜想，溢出在一位以内，事实上隐含了取模的数这个信息，因此加减法溢出运算没有丢失溢出前数据，在阿贝尔群内还是能恢复溢出前的数字的。乘法不同，截断后会丢失很多信息，这是不能恢复的。

:::

### 2.3.6 乘以常数

乘法在运算中是很占时间周期的，相比起移位，位运算和加减法。因此对于常数，我们可以利用左右移和加法加上二进制思想，实现常数的乘法。

二进制思想对于算法竞赛的人来说并不陌生，简单左移只能乘以 2，但是乘 2 以后加上原数就能实现乘 3，至于什么时候加，取决于乘的数的二进制表示。

现在部分编译器也会对常数进行改写，例如 `x*14` 改写成 `(x<<3)+(x<<2)+(x<<1)`，但具体还是取决于乘法指令的速度和移位次数。

### 2.3.7 除以 2 的幂

除法比乘法还要耗时，但是类似左移，右移也能实现除以 2 的幂，但是由于不像乘法配以加法，无法除以任何数。

对于负数，我们对于舍弃小数部分的需求是无法通过简单的算术右移实现的，此时引入一个偏置值的概念，事先加入一个偏置值，根据右移位数 $k$ 决定，事先加上 $(1<<k) - 1$ ，这样如果正好整除，没有加一，如果不整除能够将整数部分加一。

### 2.3.8 关于整数运算的最后思考

C 语言的整数运算本质上还是一种模运算，在实现上，无符号数和有符号数的位级实现也基本是一致的。其次无符号数的出现在程序设计中也比较常见，需要使用时格外小心，否则会导致很多隐晦的错误。

## 2.4 浮点数

浮点数的实现难点在于对于非常大的数字和非常接近 $0$ 的数字，以及实数运算中的近似值。在 $20$ 世纪 `80` 年代以前，各大计算机产商还是以速度和简便性为导向，没有统一的标准，一切是 `IEEE754` 标准制定后，浮点数的表示才比较统一。这项工作还是 `Intel` 赞助的，旨在为 `8087` 芯片的设计中使用一种较好的浮点数标准。

::: tip Ask ChatGPT 简单介绍 IEEE

IEEE 指的是 “电气和电子工程师学会” (Institute of Electrical and Electronics Engineers)，是全球最大的技术专业组织之一。该组织致力于推动电气、电子和计算机等领域的技术创新和发展，其会员遍布全球超过 160 个国家和地区。IEEE 的使命是通过技术的力量支持人类的利益，提供专业技术支持以及教育服务，以推动在各个领域的进步和发展。IEEE 旗下有多个不同的学会和委员会，涵盖了电力、电子、计算机、通信、生物医学、航空航天、自动化等多个领域，为会员提供各种学习和交流机会、出版物、标准等服务。

:::

### 2.4.1 二进制小数


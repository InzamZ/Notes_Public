# 第七章：多态

![多态](./img/polymorphism.svg)

## 7.1 概念引入

我们尝试使用基类指针指向一个派生类的对象，这是可行的，同时我们尝试调用一个在派生类中重写过的接口，会发生什么呢。有意思的是，此时会调用基类的接口，而直接使用派生类对象调用会调用派生类的接口。

这是奇怪的，虽然我们使用的是基类指针，但事实上指向对象还是派生类。在内存结构中，派生类其实包含了两个函数版本，但是此时由于指针类型的限制，编译器认为这是一个基类对象。其实我们可以使用类型转换来调用正确的接口，但是一点都不优雅。所以多态出现了。

## 7.2 多态的概念

多态主要有两种，事实上能解决上述问题的是动态多态，还有静态多态，实现方式都是函数重载。简单来说，多态就是一个接口，多种实现，在不同环境下呈现多种状态。

### 静态多态

通过参数，返回值的不同，我们可以很简单的实现重载。这种多态是静态的，也就是说在编译阶段，编译器通过调用参数类型判断，确定调用的具体函数版本。显然无法处理上述的情况。

> 此处需要提及一下 C 语言并不存在函数重载，可以发现编译后的函数接口只是增加了下划线，而 C++ 会在函数名后额外添加参数返回值类型。

### 动态多态

动态多态的实现是通过虚函数的机制，让对象能够正确调用自己的接口，就算基类指针指向派生类，派生类也能知道自己应该调用哪个版本的接口。这个过程是动态过程中实现的，编译器无法提前知道，只能在运行的时候判断。

## 7.3 虚函数

怎么实现呢，本质上还是函数重载，只是简单的重载无法帮助指针判断，那我们就告诉编译器，这个函数需要覆盖掉基类的版本就好了。就是利用 `virtual` 关键字声明虚函数，编译器便会覆盖这个函数。这样即使使用基类指针，因为函数覆盖也会导致调用正确函数。

### 实现原理

我们先说原理吧，编译器怎么实现虚函数呢？利用的是虚表指针和虚表，如果基类声明或者有虚函数，那么编译器会在构造对象时，在对象前面插入一个虚指针，指向一个虚表。虚表记录所有虚函数和其函数指针，覆盖实际上覆盖的就是函数指针，因此调用虚函数时，会通过虚表顺利调用正确的函数。

### 作用和性质

#### 虚特性

虚函数一旦声明，将会提醒编译器，此函数在派生类中的版本需要覆盖掉基类版本。而如果一个类声明了虚函数，或者祖先类声明了虚函数，那这个类就是多态类。可见多态类是继承的。

被修饰的虚函数都具有虚特性：

1. 虚特性必须赋予类的成员函数
2. 虚函数不能是全局函数或类的静态成员函数
3. 不能将友元说明为虚函数，但虚函数可以是另一个类的友元
4. 虚特性可以被继承。基类一旦声明了虚函数，即使派生类没有显式声明为虚函数

虚函数的设计初衷是为了覆盖，但是不是一定要覆盖呢，如果在一次继承中派生类没有需要覆盖上一个基类的版本怎么办呢。在设计原则上，最好是提供一个覆盖版本的，但是如果没有提供也是可行的，会继承基类的版本。

当然，为了设计的完整，一定要复制一个相同的版本也是可以的，但是上面提到过派生类其实有一份祖先类的拷贝，可以利用名字限定的方式调用继承的函数，同时也完成重载。

#### 确保覆盖和终止覆盖

继承关系复杂的时候，会出现应该覆盖却没有被覆盖的情况反而增加了一个**本意不是重载**的同名函数，也可能出现不应该覆盖但是却出现覆盖的情况。

前面的情况使用 `override` 防止，`override` 只是提醒编译器检查，这个函数在派生类中需要被覆盖！否则会报错，方便程序员修改。第二种情况可以通过 `final` 关键字实现，提醒编译器，这是这个函数的最终版本，不应该被覆盖。

#### 协变的覆盖

原则上，虚函数重载需要原型一致，就是说函数名，参数列表和返回值，但是有一种特殊情况，满足以下两种情况的一种：

- 两者返回的都是自己的指针，或左值引用，或右值引用。注：此时两者类型不同
- 两者返回的是同一个类 `T` 或者，派生类返回的是 `T` 的一个无二义性、可访问的祖先类
- 两者返回的指针或引用都含有 `cv-` 修饰符，并且派生类接口的修饰符等于小于基类的

这就是协变的覆盖。

### 虚析构函数

析构函数是一个典型的应用，因为不同派生类可能会有不同的变量，申请不同内存。因此虚析构函数很好地处理这一现象。然而如果你仔细阅读了虚函数的原理，就会发现构造函数的虚函数是无法实现的，也是没有意义的。

但是这就一定好吗？其实不然，简单的继承关系中，如果确保析构函数的一致性，可以不使用虚析构函数。虚函数的开销是真实存在的，大量的虚函数，需要维护大量的虚表，一切都是开销。因此使用虚函数也不可以随意，需要谨慎权衡。

## 7.4 纯虚函数和抽象类

### 纯虚函数

纯虚函数是虚函数，服务于抽象的。对于一些比较抽象的概念，很多实现是没有依据的，例如四边形的面积，很难确定。因此此时可以声明为纯虚函数，也就是没有实现。

但是纯虚函数并不是没有函数体，在声明后可以紧跟实现，不会报错但是 C++ 不推荐这么做。这是病态的写法。

### 抽象类

具有纯虚函数的类为抽象类。表示一般概念的表示，那么既然是抽象的就不能有对象，不对，不能创建抽象类的对象。但是可以声明指针和引用。抽象类只能作为其他类的基类，而且经过继承后如果还是存在纯虚函数，那么这个类还是抽象类，包括上述的病态写法也不能算作纯虚函数的实现。作为返回值和参数类型，也只能作为指针和引用，对象不被允许。抽象类不能作为显示转换的类型。

以上
